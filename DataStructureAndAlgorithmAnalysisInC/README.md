# 数据结构与算法分析 - C 语言描述

https://book.douban.com/subject/1139426/

## 第一部分 基础知识

### 第一章 引言

* 连通性问题：
  * 两个操作：查找（find）、并集（union）
  * 快速-查找（quick-find）：N 个对象，M 次合并：MN
  * 快速-合并（quick-union）：N 个对象，M 对：MN/2
  * 加权快速-合并（weighted quick-union）：遍历 2lgN 个指针：线性
  * 带等分路径压缩的加权快速-合并：保证线性
  * 在线算法（online）：能处理的数据没有限制

### 第二章 算法分析的原理

![notation](https://i.loli.net/2019/05/21/5ce3bab590bcc73556.png)

* 算法分析的种类：
  * 最坏情况（Worst Case）：任意输入规模的最大运行时间（Usually）
    * 在任何输入下运行时间的一个上界
  * 平均情况（Average Case）：任意输入规模的期待运行时间（Sometimes）
  * 最佳情况（Best Case）：通常最佳情况不会出现（Bogus）
* 基本思路：
  * 忽略掉那些依赖于机器的常量
  * 关注运行时间的增长趋势
* 渐近记号：
  * 尽管技术上 theta 符号较为准确，但通常仍然使用大 O 符号表示
  * 大 O 符号：只有渐近上界
    * 表示最坏运行情况的上界
    * T(n) = O(n^3) 等同于 T(n) ∈ O(n^3)：T(n) 的渐近增长不快于 n^3
  * theta（西塔）符号：渐近地给出了一个函数的上界和下界
    * T(n) = Θ(n^3) 等同于 T(n) ∈ Θ(n^3)：T(n) 的渐近增长与 n^3 一样快
  * omega（欧米伽）符号：只有渐近下界
* 采用记号 lgN = log_2N：改变一个对数的底只是把对数的值改变了一个常数倍，所以当不在意这些常数因子时可使用这个简便的记法
* 常见复杂度：
  * 常量：O(1)
  * 对数：O(lgN)
  * 线性：O(N)
  * 线性对数：O(NlgN)
  * 平方：O(N^2)
  * 立方：O(N^3)
  * 指数：O(2^N) O(k^N)
    * 阶乘：O(N!)：旅行商问题
* floor(x)：向下取整 x。设 x = 4.5，floor(x) = 4
* ceil(x)：向上取整 x。设 x = 4.5，ceil(x) = 5
* 调和级数：H_N = 1 + 1/2 + 1/3 + ... + 1/N

## 第二部分 数据结构

### 第三章 基本数据结构

* 客户-接口-实现
* 数组：
  * 固定有序
  * 存储空间相邻：适合访问而不是操纵
  * 两种常见错误：
    * 引用了无意义的 a[i] 内容
    * 没有保证 i 非负且小于数组大小
  * 查找（索引）：在链表中需要遍历，效率不高
  * 与向量（矢量）对应
  * 二维数组：矩阵 + 主序
* 链表：
  * 逻辑有序
  * 高效重排数据项：适合操纵而不是访问
  * 可优雅地增大和缩小
  * 自引用结构 + 循环结构
  * 末尾节点的实现细节：
    * 不指向任何节点的空链接
    * 指向不包含元素节点的哑元节点
    * 循环链表：指向第一个节点（首节点）
  * 在开头保留头节点：
    * 无数据域
    * 链域指向真正的第一个节点
    * 好处：把链表指针作为参数，使函数可修改链表，可接受或返回一个空表
    * 不保留头节点时：把指向输入链表的指针作为参数，返回输出链表的指针。这种方法适合递归链表
  * 插入：在数组中需要移动元素，效率不高
  * 删除：遍历
  * 两种常见错误：
    * 引用了未定义的指针
    * 使用了无意中修改了的指针
  * 双向链表：
    * 主要意义：只有一个节点的信息，仍然可以删除该节点
    * 适用情况：
      * 节点作为参数传递
      * 节点中有其它链接，且是其它数据结构的一部分
  * 空闲链表
  * 多重链表
* 字符串：
  * 字典顺序
* 图的表示：
  * 邻接矩阵（数组）：
    * 适合稠密图（边数多）
    * 无向图时矩阵对称
    * 检查两个顶点间是否有边相连：常量
  * 邻接表（链表）：
    * 适合稀疏图（边数少）
    * 处理所有边：正比于 V+E，而不是邻接矩阵的 V^2

### 第四章 抽象数据结构

* 广义队列（generalized queue）：
  * 操作：插入、删除
  * 随机队列：随机（等概率）得到一个项、随机删除一个项
  * 双端队列：在任何一端进行插入、删除
  * 优先队列：删除最小（最大）键
  * 符号表：删除与给定键相等的项
  * 下推栈（Push-down stack）：
    * 操作：pop、push
    * 函数调用机制
    * 后进先出（LIFO）
    * 实现：
      * 数组：
        * 固定空间：最大项的个数
      * 链表：
        * 灵活空间：所用空间与项的个数成正比
        * 栈的大小变化很大时使用
  * 先进先出队列（FIFO）：
    * 实现：
      * 数组：在头、尾分别维持两个索引
      * 链表：在头、尾分别维持两个指针

### 第五章 递归与树

* 递归：
  * 归纳基础
  * 归纳假设
* 非递归程序 = 递归程序 + 栈
* 分治法：基本递归模式
* 动态规划：实现递归程序的一般性方法
* 循环：表现为递归
* 递归的深度：取决于输入
* 消除尾递归
* 分治法：每个递归调用处理一半
  * 步骤：
    1. 分片，合并
    2. 在处理一半之后跟进
  * 与数字的二进制表示紧密相关
  * 组合-分治法：自底向上
* 背包问题：最优决策
* 动态规划：消除递归中的重复计算（存储函数值）
  * 自底向上：预先计算值
  * 自顶向上：存储已知的值，在之后的计算中优先选择
* 树、顶点、边、路径：
  * 森林：不相交的多个树
  * 树的定义：根到叶节点都是唯一路径
  * 图的定义：不是唯一路径
* 父节点、子节点、叶节点
* 树的种类：
  * 无序树（自由树）：树中任意节点的子节点之间没有顺序关系，边的集合
  * 有序树：树中任意节点的子节点之间有顺序关系
    * 二叉树：
      * 联赛
      * 形状平衡时性能好
* 树的遍历：
  * 前序：先根后左右。对应栈
  * 中序：先左中根后右
  * 后序：先左右后根
  * 层序：从上到下，从左到右。对应队列
* 图的遍历（由树的遍历推广得到）：
  * 深度优先搜索（DFS）：对应栈
  * 广度优先搜索（DFS）：对应队列，对应层序遍历

## 第三部分 排序

### 第六章 基本排序方法

* 基本的意思是：适用于小规模或特殊结构
* 基本排序方法之间的时间复杂度只相差常数因子：都与 N^2 成正比
* 可用来改进更复杂算法的效率
* 不占用额外的内存空间
* 排序：
  * 内部排序：任意访问元素
  * 外部排序：必须顺序访问
* 数组：适合顺序分配
* 链表：适合链式分配
* 非适应性：所执行的操作序列独立于数据顺序（只使用了比较-交换操作），适于硬件实现
* 自适应性：操作序列与比较结果有关，大部分算法都是这类
* 减少开销：
  * 换成更高效的算法
  * 缩短内部循环
* 额外内存空间：
  * 原位排序：小堆栈或表
  * 引用数据：N
  * 足够空间：副本
* 稳定的：相同关键字排序后位置不变
* 不稳定的：相同关键字排序后位置改变
* 强制稳定：
  * 改用稳定排序较好
  * 排序前为各关键字添加小索引
  * 加长关键字
* 访问的元素过大：使用间接排序
* 选择排序：选出最小（最大）元素，与第一个元素交换，然后对除第一个元素外的其余元素重复选择
  * 对数据不敏感
  * 对已排序或全部元素相同：等同于随机元素序列，因为未利用已有顺序，还是平方
  * 移动数据次数少：适用于大元素
* 插入排序：将较大（较小）元素（可能有多个元素）向后移动，每次有序数组大小加 1
  * 对一个有序数组插入一个新元素（有序数组的下个元素），与有序数组的每个元素从右到左比较
  * 运行时与总逆序数有关，与分布无关
  * 优化策略：
    * 提前停止执行（新元素 >= 有序数组中的元素）：因为这时新元素已插入到正确位置
    * 设置最小（最大）观察哨关键字
    * 去掉内部循环中的无用操作
  * 比较次数少
  * 对已排序文件：线性
  * 对部分排序的文件：高效，因为插入排序（和冒泡排序）执行过程中也是部分有序的
  * 对已排序的文件添加或修改：使用插入排序高效，但不适合冒泡排序
  * 效率较低的原因：交换操作只涉及近邻元素，每次只能移动一位
* 冒泡排序：遍历文件，顺序不对则交换，重复直至全部有序
  * 也属于选择排序，但需开销更多工作将元素放到合适位置
  * 内部 for 循环中：
    * 冒泡排序：从右边（未排序）向左移动
    * 插入排序：从左边（已排序）向右移动
  * 非适应性
  * 最坏、最好差别不大
  * 对已排序：线性
  * 对于小型文件：选择排序、插入排序的效率是冒泡排序的 2 倍
  * 优化：
    * 提前终止外部循环：当其中一步没有交换时，这时是已排序的
    * 鸡尾酒排序（Cocktail shaker sort）
* 希尔排序：
  * 在使文件变得 h- 有序时，通过将较大的元素右移，把元素插入在 h- 子文件中某些元素前面
  * 每第 h 个元素的集合是一个有序文件：h 个独立的已排序文件，相互交叉在一起
  * 步骤：
    1. 对 n 个元素，取一个整数 d < n。将 n 个元素分成 d 组，位置相差为 d 倍数的分成一组，每组 n/d 个元素
    2. 对 d 逐渐减小，直至为 1：对每组使用插入排序
  * 插入排序的改进：通过允许非相邻元素进行交换来提高效率
  * N^1.25
  * 步长序列：
    * 通常以几何级别减小：2 的幂
    * 能提高 25% 的效率：`for (h = 1; h <= (r-l)/9; h = 3*h+1)`：1, 4, 13, ...
    * 最好：1, 5, 19, ...
    * 最简单：1, 8, 23, ...
* 指针排序（索引排序）：不移动元素，维持一个索引数组，元素的关键字仅比较时访问。不会交换真的元素，而是交换索引，可通过索引来访问元素
  * 原位排序（合适置换、原位重排）
  * 可以避免扰乱要排序的数据和避免移动整个记录
  * 可用于对只读访问的数据排序
  * 灵活：操纵数据而不改变数据
  * 记录还是过大：还是选择使用选择排序
* 链表排序：
  * 适用于指向正在操纵的表节点的指针是由应用系统的其它部分操纵的时：这时只能改变节点中的链接，而不能改变关键字值等其它信息
  * 高效支持链表操作时才会高效
  * 排序后使得按链接访问（遍历）时是有序的，同时其它链接不改变顺序
* 关键字索引统计（计数排序）：
  * 关键字必须是在一个小范围内的整数
  * 对于 N 个介于 0-R-1 之间的关键字：线性
  * 大小为 R 的辅助表用于存放统计数
  * 大小为 N 的表用于重排记录

### 第七章 快速排序

* 在两部分有序时重排以使整个文件有序：一个选择操作，后跟两个递归调用
* 通用：易于实现
* 处理多种不同输入
* 消耗资源少
* 原位排序：小辅助栈
* 平均与 NlgN 成正比
* 最坏平方
* 不稳定：基于数组的快速排序无法稳定
* 内部循环小
* 分治（递归）：
  * 分别进行排序，每次将一个元素移到最终位置
  * 数组中有一个或零个元素时终止（基线条件）
* a[l]-a[i-1] 中的元素都比 a[i] 小（大）
* a[i+1]-a[r] 中的元素都比 a[i] 大（小）
* 左指针 l 从左扫描，直到找到比 i 大（小）的元素，停止
* 右指针 r 从右扫描，直到找到比 i 小（大）的元素，停止
* 停止并交换这两个元素，直至两个指针相遇，这时完成划分，再将右指针与 i 交换
* 当元素与 i 相等时：两个指针都停止并交换较好
* 优化策略：
  * 混合算法：在遇到小的子文件（阈值M在5-25之间）时调用插入排序
    * 几乎所有的递归算法在小问题中都会占据大部分时间
  * 三者取中划分（采样）：取三个元素的中位数作为划分元素
    * 5% 提升
    * 最坏情况几乎不可能发生
  * 随机元素（概率算法）：最坏可能性变小
  * 消除递归、用内嵌代码代替函数调用、使用观察哨
  * 三者取中划分 + 小的子文件阈值：20%-25% 提升
* 重复关键字：
  * 使用三路划分方法：
    1. 扫描时，将遇到的左子文件中与划分元素相等的放到最左边（leftEqual 指针指向），右子文件中与划分元素相等的放到最右边（rightEqual 指针指向）
    2. 然后，当两个扫描指针相遇时，等值关键字的精确位置就知道了，只需将所有等值关键字交换到划分元素两边即可
  * 数组中的元素组成：
  ![数组中的元素组成](https://i.loli.net/2019/05/22/5ce515e34bc0123612.png)
* 选择算法（第 k 大（小）元素问题）：快排中的划分过程：partition 函数
  * 平均：线性
  * 最坏：与快排相同，平方
    * 修改选择过程，可保证线性
  * 快排基础：找出文件第 k 大（小）元素
    * 将文件分为两个部分：k 个最小元素 + N-k 个最大元素

### 第八章 归并与归并排序

* 归并操作：将两个独立的文件合并成一个文件
* 将文件分为两部分来排序，对这两部分有序的文件进行组合，以使整个文件都有序
* 两个递归调用 + 一个归并过程
* 无论任何输入都为：与 NlgN 成正比，加上与 N 成正比的额外空间
* 顺序访问数据：适合链表（同样高效）、适合外部排序（多路归并）
* 两路归并：给定两个已排序文件，取出其中最小（大）文件放入最终文件
* 两个有序子文件不相交：彼此不共享元素和存储空间
* 独特应用：将新一组小文件排序，再与大文件归并
* 优化策略：
  * 对小文件改用插入排序：10%-15% 提升
  * 使用抽象原位排序来避免复制数组的额外开销：
    * 在复制时将第二个数组变成倒序（无需额外开销），因此相关的指针改为从右向左移动
    * bitonic 序列：关键字先递增再递减（或先递减再递增）
    * 不稳定
    * 代价：需要在内循环中放入检测是否到达末尾的代码
    * 解决：重新生成 bitonic 序列，这样就无需观察哨
  * 结合以上优化策略：40% 提升
* 自顶向下（Top-down，递归法）：先处理左半部分，后处理右半部分
* 自底向上（Bottom-up，迭代法）：从左到右处理其余最小的
* 自然归并排序（链表归并）：
  * 不是 ceil(lgN) 而是 ceil(lgS)，S 为原数组中有序子文件个数
  * 含有有序子文件的块：高效的
* 与快速排序的对比：
  * 归并排序：
    * 以最小开始，以最大结束
    * 分成两部分，分别处理每部分
  * 快速排序：
    * 以最大子文件开始，以最小结束
    * 大多数工作在递归调用之前就已完成

### 第九章 优先队列与堆排序

* 优先队列：
  * 插入新元素、删除最大（小）元素
  * 栈和队列的推广
  * 排序：先插入所有记录，然后依次取出
    * 无序表：选择排序
    * 有序表：插入排序
  * 重复关键字：含有最大（小）关键字值的记录
  * 堆有序树的有向链表（三链）
* 堆：优先队列的一种实现
  * 堆有序：每个关键字必定大于（小于）或等于所有子节点
  * 数组表示：根节点 a[1]、子节点 a[2], a[3]，再下一层以此类推
  * 位置：i 处节点的父节点为： floor(i/2)，两个子节点为：2i, 2i+1
  * 完全二叉树：N 个节点，路径节点约为：lgN，最下一层节点：N/2，每层节点数是下一层的一半，最多 lgN 层
  * 链表实现：
    * 三链堆有序的完全树
    * 联赛
    * 二项队列
  * 堆化（修正堆）：先侵犯堆的条件，再遍历堆，在需要的时候修改堆使其满足堆有序的条件
    * 不断与父节点（子节点）比较并交换
    * 堆底：向上遍历，直到根节点
    * 替换根节点：向下遍历，直到堆底
  * 数组中第一个元素即为堆顶，最后一个元素为树表示中最右边最下面的元素
  * 插入：在数组末尾插入新元素，然后向上堆化
  * 取出最大（小）元素：取出堆顶元素，由数组末尾元素代替，再向下堆化
  * 构造堆：
    * 一个个插入：平均线性，最坏线性对数
    * 自底向上：从数组中间开始向后扫描，对每个节点进行向下堆化。平均、最坏：线性
  * 堆排序：构造堆后，循环交换堆顶元素和数组末尾元素，并对堆顶进行向下堆化
    * 可用于第 k 大元素问题：最好常数
    * 与输入无关
    * 不稳定
    * 无额外时间
    * Floyd 改进：有最少比较次数，适用于比较开销较大的元素，但需要额外空间
* 二项队列：
  * 二项树等于 2 次幂堆：
    * 节点数为 2 的幂次
    * 根节点大于所有节点
    * 堆有序：二项树
  * 连接（join）：常量
    * 最大根节点：根节点
    * 另一个根节点：左子节点
    * 最大左子树：另一棵右子树
* 优先队列操作最坏情况

|         | 插入    | 删除最大（小） | 删除   | 找最大 | 修改优先级 | 连接    |
| :---:   | :---:  | :---:        | :---: | :---: | :---:     | :---:  |
| 有序数组 | N      | 1            | N     | 1     | N         | N      |
| 有序表  | N       | 1            | 1     | 1     | N         | N      |
| 无序数组 | 1      | N            | 1     | N     | 1         | N      |
| 无序表  | 1       | N            | 1     | N     | 1         | 1      |
| 堆      | lgN    | lgN          | lgN    | 1     | lgN       | N      |
| 二项队列 | lgN    | lgN          | lgN    | lgN   | lgN      | lgN     |
| 理论最佳 | 1      | lgN          | lgN    | 1     | 1        | 1     |

### 第十章 基数排序

* 每次只对关键字的一块进行处理
* 把关键字看作以 R 为基数的数字，对不同的 R 值（基）处理独立位
* 整数：表示为二进制数，R=2 或 R=2的幂：访问每组中的位代价较低
* 字符串类型：R=128 或 R=256，按照字节大小把基对齐
* 提取操作：从一个关键字中提取出第 i 个数字
* 最高位优先（MSD）：从左往右检查，先处理最高位，需要检查的信息最少
  * 与快排类似，根据关键字开始的几位划分，递归处理子文件
* 最低位优先（LSD）：从右往左检查，先处理最低位，先处理最不重要的数字
* 关键点：关键字索引统计：只要有足够空间存放 2^w 大小的表，就可以线性时间对 w 位关键字进行排序
* 二进制快速排序：
  * 2^b 用作划分元素（可能不在文件中）
  * 递归调用对少于 1 位的关键字调用的：次数由位数决定
  * 开始指针取决于硬件中每个字的位数、整数和负数表示方法
  * 退化时划分频繁：所有位的值都相等
  * 递归分界线：由待排数据范围和数字的二进制表示法决定
* MSD：
  * 将数组分成 R 部分
  * 文件已基本有序：效率很高
  * 优化：
    * 调整 R 的值，减少小文件：限制空桶数量：合适的基数 + 合适的划分小文件的值
    * 递归参数转换消除数组复制的开销
  * 链表实现
  * 处理缺乏随机性的数据：
    * 将所有字符串排序情况信息都考虑进去
    * 桶跨度启发式法
  * 三路基数快速排序：
    * 对关键字控制字节进行三路划分，只在中间子文件移动到下一字节（关键字的控制字节与划分元素的控制字节相同）
    * 划分操作适合关键字不同部分含有非随机的不同类型的关键字，且无需额外数组
    * 适合：
      * 重复关键字
      * 关键字位于小的范围
      * 小文件和 MSD 可能慢的情况
    * 不同基数对应的排序方法：
      * 中间大小的基数：高效处理重复关键字
      * 非常大的基数（大于字的大小）：普通快排
      * 基数 2：二进制快排
    * 适合向量：多关键字快速排序
  * 大型文件：标准 MSD：多路划分
  * 小型文件：三路基数快排：避免大量空桶
* LSD：
  * 关键字索引统计：稳定，高效
  * 基于固定长度关键字，控制关键字只在最后一遍涉及
  * 控制结构简单，基本操作适合机器语言实现，可直接改编到有特殊用途的高性能硬件中
  * 对 w- 字节的 N 个记录：与 Nw 成正比
  * 长关键字短字节：与 NlgN 成正比，需详细说明关键字中的字节数而不是关键字的数目
  * 短关键字长字节：线性
  * 最坏情况：关键字都相等，需要检查所有字节：线性
  * 随机数据：亚线性，
    * 使 lgR（每字节位数）为字大小的 1/4：
      * 从字中提取字节而不是位
      * 中途使用插入排序：2 遍
      * 4 遍关键字索引统计

### 第十一章 特殊用途的排序方法

* 应用：
  * 高性能增强的系统
  * 专门为排序设计的具有特殊用途的硬件
  * 基于某种新型结构设计的系统
* 低层模型：只允许比较-交换操作
* 高层模型：在较慢的外部介质或独立的并行处理器上读写大块数据
* Batcher 奇偶归并排序：归并排序的一种版本，基于分治归并算法，只使用比较-交换操作
  * 数据移动：
    * 完美混洗（Perfect shuffle）
      * 2^n-2^n 方阵以行为主序：n 次完美混洗：转置（以列为主序）
      * 先分成两半，先去第一半第一个元素，再取另一半第一个元素等等
      * 从 0 开始编号，前一半元素编到偶数编号，后一半元素编到奇数编号
    * 完美逆混洗（Perfect unshuffle）
      * 偶数到前半，奇数到后半
      * 用交换、混洗或类似操作来重排数据
  * 自顶向下归并：归并过程用 Batcher，属于非适应性
* 作为排序网的 Batcher 方法：
  * 比较器（比较-交换模块）：能够执行比较-交换操作的模块
  * 排序网：只能比较-交换，是一种并行计算模型
* 外部排序：
  * 从外部存储器读入，把内存写入外部存储器
  * 待排文件过大所以不能放入内存：大块形式，串行化随机高效，随机访问达到外部设备峰值性能
  * 访问记录开销巨大：排序-归并：对文件扫描，分成等于内存的数据块，对块进行排序。若干遍扫描后创建大的文件块（可选），用于将有序块归并
    * P（归并的阶数）：顺序访问：P 为可用设备的一半
    * 平衡多路归并：
      * 步骤：初始分布遍；几次多路归并遍
      * 降低开销：替换选择（增加内存）；多阶段归并（增加设备）
  * 虚拟内存：访问地址分散，不适合堆、基数排序
  * 运行时间 = 读写整个文件时间 * 所使用遍数
* 并行排序：
  * 待排文件分布在多个独立的并行处理器
  * 增加处理器，则开销（通信）增加：这时应使用 Batcher 网络
  * 处理器间的通信约束：大块数据顺序处理

## 第四部分 搜索

### 第十二章 符号表和二叉搜索树

* 符号表：
  * 操作：
    * 插入：插入一个数据项
    * 搜索：搜索一个具有给定关键字的数据项（或若干数据项）
    * 删除：删除一个特定数据项
    * 选择：选出第 k 个最小数据项
    * 排序：按关键字顺序访问所有数据项
    * 连接：连接两个符号表
  * 有相同关键字时：
    * 不同关键字的数据项 + 对于每个关键字有一条链表用于指向相同关键字
    * 相同关键字不隐藏，在一次搜索中返回所有
    * 唯一标识每个数据项
  * 手指搜索（Finger search）：搜索可从以前结束的地方开始
  * 范围搜索：统计或访问落入某个区间的节点
  * 近邻搜索：查找距离某点最近的关键字（数据项）
  * 计数（Count）操作：
    * 懒方法：Count() 函数
    * 积极方法：局部变量
* 关键字索引搜索：
  * 适用于关键字的值是不同的小整数
  * 原理：对数组中的数据项排序，然后按关键字进行索引
  * 无任何数据项（只有关键字）时：可使用位表：把第 k 位看作表示 k 是否存在于表的关键字集中的标志
* 顺序搜索：
  * 实现：把数据项按照顺序连续地存放在数组中
  * 插入：等同于插入排序（移动位置）
  * 构造表：连续插入（平方）
  * 搜索：顺序查找，当遇到的关键字大于（小于）搜索关键字时，报告失败
    * 不存在关键字时使用数组尾部作为观察哨：
      * 避免对数组尾部终止条件的测试
      * 然后搜索只会成功返回，需要判断返回的元素是数据项还是观察哨
        * 真成功：返回数据项
        * 假成功：返回观察哨
  * 不要求有序：
    * 插入：插入末尾
    * 搜索：顺序查看
    * 删除：先搜索，然后移动最后一项到这个位置，数组大小减 1
  * 实现：有序数组、无序数组、有序表、无序表
* 二分搜索：把数据项分成两部分，确定搜索关键字在某部分，然后集中处理这个部分，而舍弃另一部分
  * 标准分治法
  * 数组是有序的
  * 尾递归：递归函数是在递归调用时结束的。尾递归在非递归实现时不需要栈
  * 实现：递归执行，搜索关键字与中间元素比较，确定是在前半还是在后半
  * 对表更新时有高额开销
  * 保持有序：
    * 插入过程中动态保持：与插入数的平方成正比
    * 标准排序方法作为构造函数
  * 最大比较次数：floor(lgN)+1，也就是 N 的二进制表示中 1 的位数
  * 重复关键字：表现为重复的连续一块
    * 对给定关键字计数
    * 作为一组数返回
    * 在终止点分别向两个方向扫描，返回相等关键字的下标边界
  * 改进：更精确地猜测：插值搜索：
    * 基于关键字的值是数值型的，且为均匀分布
    * 依赖假设
    * 额外计算
    * 适用于访问开销大的外部方法
    * 把 `m = (l+r)/2` 改为 `m = l+1/2*(r-l)`，再把 1/2 改为 (v-k_l)/(k_r-k_l)，k_l、k_r 分别对应 a[l]、a[r]
    * 得：`m = l+[(v-key(a[l])) / (key(a[r]) - key(a[l]))] * (r-l)`
* 二叉搜索树：
  * 性质：任何节点都大于等于左子树所有节点，小于等于右子树所有节点
  * 插入：在搜索失败后，用指向树底的链接代替终止搜索的链接
  * 排序：中序遍历
  * 重复关键字：
    * 新节点会不连续地落在已存在节点的右边
    * 可以在找到第一个匹配点后继续搜索
    * 出现在根到外部节点的搜索关键字的路径上
  * 树的根节点对应快排中的划分元素
  * 高度：等于最坏情况下，一次搜索的开销
  * 内部路径长度：所有节点距离相加：与搜索命中的开销有关
  * 外部路径长度：与搜索失败的开销有关，外部 - 内部 = 2N
  * 距离一个节点的平均距离 = 节点个数的对数函数
  * 索引实现：
    * 索引：一种处于数据项之外的搜索结构，可以快速访问具有给定关键字的数据项
    * 无需改变树的代码，即可添加额外数组（额外信息）
    * 避免了把数据复制到内部的额外开销
    * 提前分配内存
    * 字符串搜索
  * 根节点插入：
    * 新插入的数据项在根节点：最近插入的节点都在树的上部
    * 右旋转：

      ```c
      x = h->l;
      h->l = x->r;
      x->r = h;
      ```

    * 左旋转：

      ```c
      x = h->r;
      h->r = x->l;
      x->l = h;
      ```

    * 自组织的搜索方法：搜索命中时把找到的节点带到根部，把经常访问到的节点保持在树的顶部
  * 其它操作：
    * 选择：第 k 个最小关键字问题
    * 删除：
      * 在子树中，（递归）删除该节点的结构代替原来子树
      * 在根部，合并两个子树代替原树：右子树中的最小节点变成根节点，左链接指向左子树
      * 懒删除：
        * 只标记为已删除，并忽略它
        * 可重用于未来的插入操作
        * 周期性重建：每隔一段时间就删除掉带标记的节点
    * 连接：把 1 号的根插入到 2 号去（根节点插入法），再将 1 号的左右子树分别和 2 号的左右子树两两组合
* 符号表的时间复杂度：* 表示几乎不可能出现的情况

| | 插入 | 搜索 | 选择 | 插入 | 搜索命中 | 搜索失败 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| |      | 最坏 | | | 平均 | |
| 关键字索引数组 | 1 | 1 | M | 1 | 1 | 1 |
| 有序数组 | N | N | 1 | N/2 | N/2 | N/2 |
| 有序链表 | N | N | N | N/2 | N/2 | N/2 |
| 无序数组 | 1 | N | NlgN | 1 | N/2 | N |
| 无序链表 | 1 | N | NlgN | 1 | N/2 | N |
| 二分搜索 | N | lgN | 1 | N/2 | lgN | lgN |
| 二叉搜索树 | N | N | N | lgN | lgN | lgN |
| 红黑树 | lgN | lgN | lgN | lgN | lgN | lgN |
| 随机树 | N* | N* | N* | lgN | lgN | lgN |
| 散列 | 1 | N* | NlgN | 1 | 1 | 1

### 第十三章 平衡树

* 最坏情况：
  * 已有序文件
  * 大量重复关键字
  * 逆序
  * 大小关键字交替
  * 其中任意片段具有简单结构的文件
* 平衡方法：
  * 显式地进行周期性再平衡：缺点：
    * 重新插入关键字对时间可能随插入序列长度呈平方递增
    * 每次平衡至少花费基于树大小的线性时间
  * 随机化：降低最坏情况出现的机会（无论输入）：随机化的 BST 和跳跃表
  * 平摊：每次做额外工作，从而避免以后做更多工作：伸展 BST
  * 优化：为每个操作提供性能保障：自顶向下 2-3-4 树和红黑树
* 随机化 BST：按概率进行根插入
  * 新纪录的最终位置在搜索路径上的任何地方（随机判定）
  * 与输入无关
  * 等价于用该树的关键字的随机排列来建立标准 BST
  * 缺点：
    * 生成随机数的开销
    * 每个节点需要记录子树节点个数
* 伸展 BST：伸展操作消除了最坏情况的平方时间
  * 插入：
    * 不同定向：标准根插入法
    * 相同定向：在根处进行两次旋转
  * 平摊性能保障：虽然不能保证每个操作都是高效的，但可以保证所有操作的平均开销是高效的
  * 重复关键字：会排列到节点的两边
  * 优点：
    * 自组织
    * 频繁访问一个小型关键字集合
* 2-3-4 树：
  * 2-节点：1 个关键字 k，2 个指针 p1, p2。p1 指向比 k 小的子树，p2 指向比 k 大的子树
  * 3-节点：2 个关键字 k1, k2，3 个指针 p1, p2, p3。p1 指向比 k1, k2 都小的子树，p2 指向在 k1, k2 之间的子树，p3 指向比 k1, k2 都大的子树
  * 4-节点：3 个关键字 k1, k2, k3，4 个指针 p1, p2, p3, p4。p1 指向最小，p2 指向 k1, k2 之间，p3 指向 k2, k3 之间，p4 指向最大
  * 分裂：把 4-节点分裂成两个 2-节点，把中间关键字传给父节点
  * 自底向上：
  * 自顶向下：搜索过程每遇到 4-节点就分裂
    * 优点：一次遍历过程就可达到所需的平衡
    * 树根变成 4-节点：分裂成一个由 3 个 2-节点组成的三角形
* 红黑树：
  * 思想：把 2-3-4 树表示为标准 BST（只有2-节点），每个节点增加一个信息位来存放指向那个节点的链接的颜色
  * 红链接：2-3-4 树中节点中的内部链接，是由 3-节点和 4-节点组成的小二叉树
  * 黑链接：2-3-4 树中的普通链接
  * 两种结构的优点：
    * 标准 BST 的简单搜索过程
    * 2-3-4 树的简单插入-平衡过程
  * 只有看到 4-节点时才平衡
  * 重复关键字：必须允许相等落入两边
  * 最坏情况有保障
  * 随机数据时有最快的插入和搜索
* 高度平衡树（AVL树）：每个节点的子树高度最多相差 1
* 2-3 树：只有 2-节点和 3-节点
* 跳跃表：
  * 完全忽略 2-3-4 树的抽象：形式化一个插入算法，使它通过旋转操作保持平衡红黑 BST 性质
  * 定义：有序链表，每个节点有不定量的链接，第 i 个链接跳过有小于 i 个链接的节点（i个跳过少于i个）
  * 随机化
  * 稳固结构：插入时很难维护
  * 少于其它方法的空间需求，又能提供对数性能

### 第十四章 散列

* 处理不规则的关键字
* 通过算术运算把关键字转换成表中地址来直接引用表中元素
* 解决冲突：
  * 链表：关键字数目无法预知
  * 数组：固定数目
  * 方法：
    * 链地址法
    * 开放地址法：用空的存储空间来解决冲突
      * 线性探测法
      * 双重散列表
    * 动态散列表
* 空间换时间：标准散列（关键字索引）
* 时间换空间：顺序搜索
* 缺点：
  * 运行时间依赖于关键字长度
  * 选择、排序的功能无法高效实现
* 散列函数：
  * 不同关键字映射到不同地址
  * 冲突：多个关键字对应同一地址
  * 希望避免显示类型转换，将关键字的二进制表示用作算术运算
  * 对于 w-位整数：
    * 模散列函数：k % M
    * 关键字乘 0-1 之间的常数，再做模 M 运算
  * 关键点：应该考虑到关键字的所有位
  * 应该取素数（质数）作为表长
  * 默森尼素数：当 t = 2, 3, 5, 7, 13, 19, 31 时，2^t-1 为素数
  * 对于较长字母序列：
    * 霍纳算法：从左到右计算编码字符串：每个字符的十进制求和后乘基数（应取素数），再加上下一个字符的编码值
    * 计算长整数时，每步去掉 M 的倍数
  * 通用散列算法：在计算中使用随机系数，并对关键字每位数采用不同随机值
    * 冲突几率为表大小 M 的倒数：1/M
    * 对长关键字比较耗时，可通过分段处理来解决
* 链地址法：每个地址对应一个链表
  * 易于实现，特别是删除操作，在实际中经常使用
  * 无序链表：
    * 插入：常量，很快
    * 搜索：与 N/M 成正比（M为地址，N为关键字）
    * 每个链表就像栈一样，可以删除最近插入的元素
  * 有序链表：搜索加快 1 倍，插入减慢
* 线性探测法：冲突发生时使用下一个空位置
  * 聚集：多个元素聚合在一段连续空间
  * 最好情况：偶数地址为空，奇数地址为满
  * 最坏情况：表的后半段满，前半段空
  * 删除：
    * 将被删除元素到右边下一个空位置之间的元素重新散列
    * 将被删除元素用观察哨替换
  * 相对于其它方法来说最快，但前提是要有足够内存且表稀疏
* 双重散列表：冲突发生时，使用第 2 个散列函数来找到空位置
  * 搜索增量：
    * 必定非 0
    * 应该与表的大小互素
  * 装填因子越接近 1，线性探测开销就越比双重散列开销大
  * 可以使用比线性探测更小的表来得到相同的平均搜索时间
  * 使用内存最高效，但需计算第 2 个散列函数
* 动态散列表：当表中元素数量到达某个阈值（1/2）时使表长加倍，而到达另一个阈值（1/8）时使表长减半
  * 当插入操作使表为 1/2 时加倍
  * 当删除操作使表为 1/8 时减半
  * 永远介于 1/8 和 1/2 之间
  * 加倍和减半的阈值应该不同
  * 适合使用模式无法预知的情况
* 特殊散列：
  * 在双重散列插入时把元素来回移动（第1个散列函数得到的地址与第2个交换），使搜索命中率更高
  * 有序散列：在线性探测中引入排序，使搜索失败的开销接近于搜索成功，等同于对链地址法中的链排序
  * 异常字典：几乎所有的搜索都应该是失败的，失败搜索快，成功搜索慢

### 第十五章 基数搜索

* 优点：
  * 最坏情况下较好的搜索性能，而无需平衡树的复杂算法
  * 对变长关键字易于实现
  * 有些算法在搜索数据结构中提前排序
  * 与二叉树、散列相比，可快速访问数据
* 缺点：
  * 空间使用效率低
  * 不能高效访问位时，搜索性能也会受到影响
* 数字搜索树（DST）：左链接代表 0 的选择，右链接代表 1 的选择
  * 根据某位的测试来决定向左子树还是右子树前进
  * 子节点根据关键字某位的比较结果
  * 适合关键字数目很大，但字长相对较小的情况
  * 最长路径由最长关键字的位数来决定
  * 如果关键字是定长的，那么搜索时间也由关键字位数决定
* Trie（线索，二叉搜索线索，前缀树，字典树）：
  * 关键字有序，且关键字只存储在树的底端（叶节点）
  * 结构：
    * 外部节点：空孩子
    * 叶节点：左右链表为空的内部结点
  * 比较位为 0 时，进入左子树
  * 比较位为 1 时，进入右子树
  * 搜索：先用位比较来遍历，最后在叶节点进行一次关键字比较
  * 与输入顺序无关：任一无重复关键字序列，存在唯一线索
  * 比 BST 更平衡：从中间将关键字分类的概率更大
  * 缺点：当关键字位多数都为相同时
  * 节点数目加倍：搜索开销仅增加一次比较操作
  * 对于长关键字降低开销的方法：
    * 把单树枝压缩成单链接来缩短路径长度
    * 使每个节点包含多于 2 个链接
  * 与二叉快速排序（二进制快排）对应，空链接对应空桶
* 帕氏线索：
  * 解决标准线索的缺点：
    * 单路分支导致多余节点
    * 两种类型节点使得代码变得复杂
  * 避免单路分支：存储要测试的位的序号，跳过位相同的关键字
  * 避开外部节点：使用指向相应线索中内部节点的链接
  * 只比较节点中数指示的关键字的位，忽略节点中关键位，当第一次到达向上指向的链接时比较关键字
  * 适合关键字较长
  * 中序遍历访问节点
* 多路线索：
  * 每次比较 r 位，可使搜索加快 r 倍
  * R 叉线索：节点为 R 个链接，每个链接代表一种可能的取值
  * 无节点标号，因为可以从父节点链接数组中指向其本身的链接推导出来
  * 与多路基数排序对应
  * 三叉搜索线索（TST）：节点中有 1 个关键字和 3 个链接。链接分别对应小于、等于、大于节点
    * 与三路基数排序对应
    * 改进：在树根直接使用大型多路节点
    * 优点：
      * 使用关键字不规则（关键字并不随机）
      * 搜索失败时也很高效，即使关键字很长
      * 支持比符号表更广泛的操作：如部分匹配搜索
      * 与帕氏线索相比，访问字节而不是位
* 后缀树（字符串索引）：由指向字符串的指针组成
  * 线索方法
  * 文本固定，无需动态插入排序
  * 带有字符串指针的二叉搜索（可保证的对数搜索时间）

### 第十六章 外部搜索

* 维护对数据的索引：
  * 不复制副本：
    * 需要相当多的额外空间
    * 避免多个副本造成数据不统一
  * 记录是对实际数据的引用
  * 主要参数：
    * 块大小
    * 相对访问时间
* 索引（目录）顺序访问（索引顺序存取）：把关键字和记录的引用按关键字有序放在数组，使用二分搜索
  * 改进：
    * 二叉树（索引太大）：
      * 内部节点：关键字 + 页面引用
      * 外部节点：关键字 + 记录指针
    * M 叉树：访问 M 表的开销和访问 2 表相同
  * 缺点：修改目录的开销很大
* B 树：
  * 定义：
    * M 阶 B 树由 k-节点组成，每个节点有 k-1 个关键字和 k 个指向树的链接，链接表示关键字的 k 个间隔
    * 对于根节点，k 在 2 和 M 之间；对于其它节点，k 在 M/2 和 M 之间
    * 所有指向空树的链接到根节点的距离都相等
  * 带有记录引用的关键字保存在树底部的外部页面
  * 带有页面引用的关键字的副本保存在内部页面
  * 速度和灵活性来源于节点内的未用空间
  * 每次搜索和插入都会访问根节点，根节点一定会在缓存中
  * 删除：
    * 自然方法：用兄弟节点中的数据项来填充删除的空间
    * 简单方法：使节点保持非满
  * 改进：
    * 把尽可能多的页面引用保存在一个节点中：节约时间开销、分支因子增大、树更扁平
    * 在分裂前把节点与其它兄弟节点组合：提高存储效率
* 可扩展散列：
  * 如同散列：随机算法，第一步是定义一个散列函数（由关键字得到整数）
  * 如同多路线索：使用关键字前几位索引到一个大小为 2 的幂的表
  * 如同 B 树：把数据项存储在页面中，填满时分裂，有序的
  * 如同索引顺序访问：维持一个目录，由目录搜索关键字可对应到页面
  * 定义：阶数为 d 则是一个含有 2^d 个页面引用的目录，目录中有 2^{d-k} 个指向页面的指针，起始于前 k 位决定的位置，页面中数据项不超过 M，关键字前 k 位相同
  * 可由线索转换而来
  * 与插入顺序无关
  * 删除：
    * 简单方法：允许页面不满
  * 整个目录都在缓存的可能性不大
  * 改进：
    * 把目录组织成单一指针数组（把目录放在内存中）
    * 把树根保存在内存中
    * 增加一层数据，对第一层前 10 位索引，第二层对其余位索引

## 第五部分 图算法

### 第十七章 图的性质

* 图的定义：元素的集合 + 元素之间连接的集合
* 图论是组合数学的一个主要分支
* 图的应用例子：地图；超文本；电路；调度；事务；匹配；网络；程序结构
* 任何链式结构都是图的一种表示
* 树和链表的算法都是图算法的特例
* 算法的开销：元素集性质 + 连接集性质
* 术语：
  * 图：顶点集 + 边集
  * 约定：V：顶点数；E：边数
  * 边将一对不同的顶点连接在一起，每对顶点间至多有一条边连接
  * 重复边（平行边）：每对顶点间可有任意边相连（多重图）
  * 自环：顶点连接到自身的边
  * 简单图：无重复边 + 无自环
  * 带自环的多重图
  * 边数：V 个顶点至多有 V(V-1)/2 条边
  * 称谓：
    * 点：顶点、结点（数据结构）
    * 边：边、链接（数据结构）、弧
  * 关系：
    * 一条边连接两个顶点
    * 两个顶点是相互邻接的：A、B 相互邻接
    * 这条边是依附于这两个顶点的：C 依附于 A、B
  * 顶点的度：依附于这个顶点的边数
  * 子图：原图的边子集 + 顶点子集组成的图
  * 导出子图：
  * 绘图：把顶点放在平面上，并画出边
    * 约束：边不相交
  * 平面图：能在平面上画出的，且边不相交的图
  * 欧几里得图：距离相关的图
  * 图同构：有两个图，改变其中一个图的顶点编号后的边集与另一个图相同
    * 对于顶点编号有 V! 种可能
  * 路径：顶点的序列，其中相邻的顶点在图中也是相邻接的
    * 简单路径：顶点和边都不相同
      * 环：第一个顶点和最后一个顶点相同，且为简单路径
    * 回路：第一个顶点和最后一个顶点相同，但不必是简单路径
      * 周游路径：包含图中所有顶点的回路
    * 长度：边数
    * 不相交的：
      * 顶点不相交：两条简单路径除端点外无公共顶点
      * 边不相交：没有公共边
  * 连通图：任意顶点到任意顶点都有路径
    * 不连通的图由数个连通分量组成
    * 最大连通分量：在该子图中的顶点没有到图中其它顶点的路径
  * 树：无环连通图
  * 森林：树的集合
  * 生成树（连通图）：子图中包含所有顶点，且是一棵树
  * 生成森林（图）：子图中包含所有顶点，且是一个森林
  * 图是树的条件：各为充分必要条件
    * 有 V-1 条边，且无环
    * 有 V-1 条边，且连通
    * 每对顶点间只有一条简单路径
    * 图连通，但删除任意边后就不连通了
  * 完全图：所有顶点与所有顶点间均有边相连
  * 补图：完全图 - 原图（边相减，顶点不变）
  * 图的并集：边集的并集导出
  * 任意有 V 个顶点的图都是有 V 个顶点的完全图的子图
  * 有 V 个顶点的图形式共有 2^{V(V-1)/2} 种
  * 团：一般图中出现的完全图子图
  * 图的稠密度：平均顶点度：2E/V
  * 稠密图：平均顶点度与 V 成正比：E 与 V^2 成正比
  * 稀疏图：补图为稠密图的图
  * 二分图：顶点分为两个集合，任意边依附的顶点来自不同的集合
    * 递归：任何子图也是二分图
  * 有向图：边是单向的，顶点对是有序的（不能任意调换位置）
    * 有向边：箭头表示：v->w
      * 第一个顶点：源点（头，head）
      * 第二个顶点：目的点（尾，tail）
    * 顶点：
      * 入度：进入该点的边数（以该点为目的点的边数）
      * 出度：离开该点的边数（以该点为源点的边数）
    * 有向环
    * 有向无环图（DAG）
    * 潜在无向图：边可以解释为是无向的
  * 加权图（网）：边关联权值或顶点关联权值，可有多个权值
* 图的 ADT：
  * 静态图：有固定的顶点和边
  * 动态图：图处理时会有边或顶点的插入和删除：在线算法（动态算法）
  * 任务：
    * 计算图中某个度量的值：连通分量数；最短路径
    * 计算图中某个边子集：生成树；含给定顶点的最长环
  * 图表示的要求：
    * 包含应用中的图类型（不愿意浪费空间）
    * 有效构造所需的数据结构
    * 算法不过度受到表示的约束
  * 邻接矩阵：稠密图：E 与 V^2 成正比
  * 邻接表：稀疏图：与 V+E 相比来说 V^2 很大
* 边数组：

![边数组](https://i.loli.net/2019/05/27/5cebadc17254e74716.png)

* 邻接矩阵表示：
  * 定义：
    * V*V 的布尔数组，有权值时为整数数组
    * 二维数组
    * 有 v-w 这条边时，v 行 w 列值为 1
    * 空间：V^2
  * 无向图时是对称的，可以根据这个特性来节省空间
  * 自动不允许平行边，其它表示时不允许平行边需要很大的开销
  * 使用的理由：
    * V^2 很小，使表示的时间可被忽略
    * 算法多于 V^2 步
* 邻接表表示：
  * 定义：
    * 将在图中与某顶点邻接的顶点都放入一条链表中
    * 使用链表数组，给定顶点可访问到那条链表
  * 链表的特点：增加新边只需常量时间
  * 空间：与 V+E 成正比
  * 检查重复边需搜索链接表，与 V 成正比
  * 删除边：与 V 成正比
  * 链表中元素顺序有异
  * 改进：常量时间的删除边和平行边检测
  * 缺点：检查边与 V 成正比
  * 符号表：常量查找边
  * 变长数组（大型静态表）
* 变量、扩展和开销：
  * 改进：
    * 扩展基本结构可表示其它类型的图
    * 修改或增大数据结构使某些操作更高效
  * 检测 v 的度是否为 0：
    * 邻接矩阵：每行每列与 v 对应的元素
    * 邻接表：adj[v]
    * 边数组：所有 E 边
    * 顶点索引数组可以常量时间
* 边数组、邻接矩阵和邻接表开销：

|                 | 边数组 | 邻接矩阵 | 邻接表 |
| :---:           | :---: | :---:   | :---: |
| 占用空间         | E     | V^2     | V+E   |
| 初始化为空        | 1    | V^2     | V     |
| 复制             | E    | V^2     | E     |
| 销毁             | 1    | V       | E     |
| 插入边           | 1    | 1       | 1     |
| 查找或删除边      | E    | 1       | V     |
| v 的度是否为 0    | E    | V       | 1     |
| u 到 v 是否有路径 | ElgV | V^2     | V+E    |

* 图生成器：
  * 随机图生成器：
    * 随机边：出现大量自环和平行边，适合稀疏图
    * 随机图：排除了重复边，边数不准确，适合稠密图
  * 图的类型：K-近邻图；欧几里得近邻图；事务图；函数调用图；分离度图；区间图；de Bruijn 图
* 简单路径、欧拉路径和哈密顿路径：
  * 找出连接两个给定顶点的一条路径：线性
  * 图算法中线性代表：在图规模 V+E 的一个常量因子内
  * 哈密顿路径：给定两个顶点有一条简单路径，且访问图中所有顶点一次
    * 哈密顿回路问题：从顶点又回到自身
    * 最坏：指数
  * 欧拉路径：给定两个顶点有一条路径访问图中所有边一次（路径可非简单路径，顶点可访问多次）
    * 欧拉回路：从顶点又回到自身，图连通，且所有顶点为偶数度数
    * 欧拉路径：图连通，且只有两个顶点为奇数度数
    * 直接递归实现：阶乘
    * 可达到线性
* 图处理问题：
  * 简单（容易）：可用某种精致而有效的小程度解决
    * 简单连通性；有向图中的强连通性；传递闭包；最小生成树；单顶点最短路径
  * 易解的：时间、空间由图规模（V+E）的一个多项式函数限定
    * 平面性；匹配；有向图中偶环；指派；一般连通性；邮差问题
  * 难解的（NP-难）：无合理时间
    * 最长路径；可着色性；独立集；团
  * 未知的：无高效解，且无法认定为 NP-难问题
    * 图同构

### 第十八章 图搜索

* 定义：系统地检查图中每个顶点和每条边
* DFS：
  * 解决连通性问题
  * 两种实现：
    * 递归（系统栈）
    * 显式栈
* BFS：
  * 解决最短路径问题
  * 实现：用队列替代 DFS 中的栈
* 探索迷宫：
  * Trémaux 搜索：
    * 步骤 1, 2, 3
    * 可访问所有顶点和边
    * 右手靠墙时，且图中有环路时无法探索整个迷宫
    * 根据通道有 4 种情况：1, 2, 3, 4
* 深度优先搜索：对顶点标记，然后递归地访问与该顶点邻接，且未被访问过的顶点
  * 遇到 v-w 边时：
    * w 未被标记：递归调用
    * w 已被标记：跳过
    * 相反边 w-v：忽略
  * DFS 树（递归调用树）：搜索过程的一种结构性描述
* 图搜索 ADT 函数：
  * 图搜索方法：
    * 从顶点到顶点沿着边行进，目的是为了系统地访问每个顶点每条边
    * 图不连通时（多个连通分量）：每个连通分量调用一次
    * 步骤：
      1. 查找一个未标记的顶点（起始顶点）
      2. 访问包含起始顶点的连通分量重的所有顶点，并标记为已访问
      3. 直至图中所有顶点都被标记为已访问
    * 每条边定量处理：线性或近似线性
  * DFS 运行时间：
    * 邻接矩阵：与 V^2 成正比
    * 邻接表：与 V+E 成正比
    * 与图规模呈线性
  * DFS 函数：基于 DFS 模式的所有实现
  * 使用基于顶点索引的数组：
    * 全局变量：搜集图结构的信息
    * 在图的表示中：计算图信息预处理函数
    * 作为函数参数由客户提供：实现 ADT
  * 标准邻接矩阵 DFS
  * 标准邻接表 DFS
* DFS 森林的性质：
  * DFS 访问结点的顺序与前序遍历树的内部结点的序列相同：图搜索为树遍历的推广
  * 边：检查边等同于访问边
    * 树边：表示递归调用的边
      * 第一次：树链接：w 未被初始化：递归调用
      * 第二次：父链接：st[w] 为 v：忽略
    * 回边：将某顶点与它的 DFS 树中祖先顶点相连的边，且该祖先不是其父结点
      * 第一次：回链接：pre[w] < pre[v]（st[w] != v），pre[] 为前序编号：未完成
      * 第二次：下链接：pre[w] > pre[v]：已完成
  * 连通分量个数 = DFS 森林中树的个数
* DFS 算法：
  * 应用：
    * 环检测：一次 DFS 中无回边或向下边则表示无环
      * 邻接矩阵：与 V^2 成正比；邻接表：与 V 成正比
    * 简单路径：线性
    * 简单连通性：线性，图只调用 DFS 一次
    * 双向欧拉回路
    * 生成树：DFS 树
    * 顶点搜索：顶点计数
    * 2-可着色性、二分图性、奇环：按照层次交替指定颜色，并在着色过程中检查回边是否存在不一致性
* 可分离性和双连通性：
  * 桥（可分离的边）：图中的某条边，当删除它时会让一个连通图分成两个不相交的子图
  * 边连通的图：不含有桥的图：每对顶点由两条边不相交的路径连接，边不相交意味着可由公共点，但不能有公共边
  * 边可分离的图：不是边连通的图
  * 边连通分量（桥连通分量，不含桥的最大子图）：删除一个边可分离的图中的所有桥而得到的分量（子图）
  * DFS 树中的树边 v-w 是桥，当不存在回边时，把 w 的子孙结点和 w 的祖先结点连接起来
  * 识别桥：线性
  * 关结点（分离顶点、切割点）：图中的某个顶点，当删除它时会让一个连通图分成至少 2 个不相交的子图
  * 可分离的：图不是双连通的
  * 顶点连通的图（双连通的图）：
    * 图中每对顶点都有两点不相交的路径
    * 不含关结点的图
    * 顶点连通的图都是边连通的，但边连通的图不一定是顶点连通的
  * 找出关结点和双连通分量：线性
  * 顶点：1 连通 = 连通；2 连通 = 双连通
    * 图是 k 连通的：至少有 k 条不相交的路径连接每对顶点
    * 图的顶点连通度：将图分成 2 部分所要删除的最小顶点数
    * Menger 定理：顶点连通度 = 顶点间顶点不相交路径的最大个数
  * 边：2 边连通 = 边连通
    * 图是 k 边连通的：至少有 k 条边不相交的路径连接每对顶点
    * 图的边连通度：将图分成两部分所需删除的最少边数
  * st 连通性：将 s、t 分离所需删除的最小边数或顶点数
  * 一般连通性：图的边连通度或顶点连通度
* 广度优先搜索：
  * 定义：为了找出从 v 到 w 的一条路径，从 v 开始，对于可以从 v 用 1 条边到达的所有顶点，检查这些顶点是否为 w。不是则检查从 v 用 2 条边到达的顶点，3 条边以此类推。直到找到 w
  * 队列用作边缘集的数据结构
  * 队列中的边将访问过的顶点与未访问过的顶点相连
  * 顶点按照与起始顶点的距离大小进入或离开队列：0, k, k+1
  * 步骤：
    1. 从队列中取边，直到某条边指向一个未被访问过的顶点
    2. 访问该顶点，再将从此顶点到未被访问顶点的所有边放入队列中
    3. 直至队列为空
  * 以 v 为根的 BFS 树，树中某点 w 到 v 的路径对应着图中 v-w 的最短路径
  * 邻接矩阵时：与 V^2 成正比
  * 邻接表时：与 V+E 成正比
  * 应用：
    * 最短路径（点到点）
    * 单源点最短路径（点到所有点）
    * 所有对之间最短路径（对每个点执行单源点）
* 广义图搜索：
  * 边缘集：下一次向树中添加的可能候选边集合
  * 通用方案：将边缘集中的一条边移到树中，访问这条边指向的顶点，并将由该顶点指向未访问顶点的所有边放入边缘集中，在边缘集中使用一种替换策略来保证其中任意两条边都不指向同一顶点
  * 无重复目的顶点：
    * BFS：忽略新元素的队列
    * DFS：忘记旧元素的栈
  * 广义队列（V）+ 替换策略 = 线性访问所有顶点和所有边，空间与 V 成正比
    * 邻接矩阵：与 V^2 成正比 + 最坏情况下 V 次插入、V 次删除、E 次更新
    * 邻接表：与 V+E 成正比 + 最坏情况下 V 次插入、V 次删除、E 次更新
  * 策略：随机队列；优先队列
* 图算法分析：
  * 寻求理然的、自然的输入模型：设计-分析-实现-测试
    * 充分反映实际：大量类型的图
    * 数学分析检验：数学分析有难度，很多基本分析问题尚未定论
    * 生成器、问题实例：无法刻画在实际中出现的图类型
  * 大型的非稀疏随机图很可能是连通的
  * 对于大型稀疏图不应该使用邻接矩阵表示（超大型同样不应该）：初始化数组开销昂贵、算法需要检查数组的每个元素
  * 为大型稀疏图构建邻接表时，为链表结点分配内存的开销很大，为遍历的 5 倍：考虑预先分配数组来降低内存分配的开销
  * 递归 DFS 在图过大时会崩溃：使用非递归版本（栈）
  * 合并-查找快于 DFS 或 BFS：因为它不必表示整个图

### 第十九章 有向图和无向图

* 有向图中两个顶点有 4 种方式：无边；s->t；t->s；s->t 且 t->s
* 调度问题：完成工作，且不违反优先关系
  * DAG、拓扑排序
* 后面的工作（顶点或边）完成前需要完成前面的：
  * 顶点对应工作
  * 边对应工作：PERT 图
* 环检测；拓扑排序；传递闭包和强连通分量
* 术语和游戏规则：
  * 有向图：顶点集 + 连接有序顶点对的有向边集（不含重复边）
  * 通常约定每个顶点都有一个自环
  * 有向路径：是一个顶点序列，相邻顶点在图中是有边相连的
  * s、t 可达的：存在 s 到 t 的路径
  * 入度：指向该顶点的边数
  * 出度：从该顶点指出的边数
  * 源点：入度为 0 的顶点
  * 汇点：出度为 0 的顶点
  * 求入度、出度、源点、汇点：线性，空间则与 V 成正比
  * 映射：允许自环，且所有顶点出度为 1 的有向图，一个将 0~v-1 上的整数集映射到自身的函数
  * 逆图：由原图所有边上的方向逆转得到
    * 邻接矩阵：转置（交换行和列），如果是不再修改的，就只用交换对行和列的引用
    * 邻接表：
      * 与 E 成正比构建
      * 维护每条边的两种表示（如无向图），且使用额外一位表示方向（可用指针关联这两条边）
  * 有向环：由某个顶点回到其自身的简单有向路径，顶点和边都是不相同的
  * 有向无环图（DAG）：没有有向环的有向图
  * 有向图是强连通的：每个顶点均由每个顶点可达
  * s、t 是强连通的（相互可达的）：s->t 有路径，且 t->s 也有路径：等价关系
  * 环路径：由某个顶点回到其自身的路径，该路径不必是简单地
  * 非强连通有向图的组成：一组强连通分量（强分量）+ 由一个连通分量到另一个连通分量的一组有向边，其中强连通分量就是最大连通子图
  * 核心 DAG：一个由普通有向图转换得来的 DAG，DAG 中每个顶点代表一个强连通分量，顶点间的有向边也对应原图中两个强连通分量中的顶点是否有边相连
* 有向图中的 DFS 剖析：
  * 有向图中树链接与图中的边一一对应：
    * 指向未访问顶点：
      * 树边：递归调用
    * 指向已访问顶点：
      * 回边：顶点到祖先结点：较大后序编号
      * 下边：顶点到子孙结点：较大前序编号
      * 交叉边：顶点到非祖先非子孙结点：较小前序编号
  * 有向环检测（DAG检测）：DFS 时无回边
  * 单源点可达性：DFS 时间与可达顶点导出的子图中边个数成正比
* 可达性和传递闭包：
  * 传递闭包：与原图有相同顶点，当原图中 s、t 有路径是，传递闭包中有边 s->t
    * 布尔矩阵相乘：可使用任何传递闭包算法计算，最多差常数因子（最好V^2.5）有向边
    * 计算传递闭包：
      * 简洁方法（反复平方法）：有邻接矩阵 A，计算 A^V：与 V^3lgV 成正比
      * Warshall 算法：与 V^3 成正比
        * 适合稠密有向图
        * 改进：把对 A[s][i] 的测试从内循环移出
      * 基于 DFS 的传递闭包：时间：与 V(V+E) 成正比，空间：与 V^2 成正比
        * 适合稀疏图
        * 邻接矩阵表示
        * 邻接表表示：对于稀疏图来说最快
      * 抽象传递闭包：测试可达性的 ADT，时间：V^3，空间：V^2
      * Floyd 算法求加权图最短路径
* 等价关系和偏序：
  * 集合中对象的关系：对象的有序对集合
  * 关系与有向图是同一个抽象的不同表示
  * sRt 表示有序对 (s, t) 之间存在关系 R
  * 关系种类：
    * 对称的：sRt 蕴含着 tRs：无向图
    * 自反的：对所有 s 有 sRs：所有顶点均有自环的图
    * 反自反的：对所有 s 没有 sRs：所有顶点均无自环的图
    * 传递的：有 sRt、tRu，则有 sRu
  * 等价关系：自反、对称且传递
    * 示例：模运算；图的连通性
    * 等价类：`s \equiv t` 表示在同一个等价类中
  * 偏序关系：反自反、非对称和传递
    * 示例：子集包含；DAG 中的路径
  * 全序关系：对于 s != t，有全序 T 为 sTt 和 tTs 只能有一个成立
  * 集合和图模型的对应关系：
    * 关系：有向图
    * 对称关系：无向图
    * 传递关系：图中路径
    * 等价关系：无向图中路径
    * 偏序关系：DAG 中的路径
* 有向无环图：
  * 调度：在约束下完成任务：拓扑排序
    * 约束：所需时间的函数或者任务消耗的其它资源的函数，例如：优先约束：某些任务必须在其它一些任务前执行
  * 树表示压缩成 DAG 表示（动态规划）
  * 二叉树：一个有向无环图，每个结点可发出两条边，且可接受一条边
* 拓扑排序：
  * 目标：处理 DAG 的所有顶点，使得每个顶点在指向的顶点之前被处理
  * 重新编号的拓扑排序
  * 重新排列的拓扑排序，也就是常用的术语拓扑排序，与重新编号的拓扑排序相互可得
  * 产生的顶点顺序非唯一
  * 逆拓扑排序：边从右指向左
    * 可由 DFS 的后序编号而得
    * 正常拓扑排序步骤：
      1. DAG 逆图上进行逆拓扑排序
      2. 栈
      3. 逆序对顶点编号
  * 每个 DAG 至少有一个源点和一个汇点
  * 基于源点队列的重新编号拓扑排序步骤：
    1. 从队列中删除一个源点，并对其标号
    2. 减少某些顶点的入度
    3. 入度为 0 时，将顶点放入源点队列
    4. 直到源点队列为空
* 有向无环图中的可达性：
  * 利用动态规划和 DFS，对于 DAG 的抽象传递闭包
  * 设 X 为 DFS 森林中交叉边的数目：时间：与 V^2+VX 成正比，空间：与 V^2 成正比
  * 稠密 DAG 的传递闭包：最坏 VE，但也有一般情况较快的算法
* 有向图中的强连通分量：
  * DAG 中，s->t 有路径，则 t->s 无路径
  * 强连通分量（强分量）：由相互可达的顶点组成
  * 蛮力算法：使用传递闭包算法，检查每对顶点对 s->t 是否可达，且 t->t 是否可达，将满足此条件的顶点对定义为无向图的一条边，此无向图的连通分量就是原图（有向图）的强分量
  * Kosaraju 算法：
    * 步骤：
      1. 构建逆图，并用 DFS 计算一个后序序列（有向图是 DAG 时为拓扑排序）
      2. 在原图执行 DFS，在调用递归函数的搜索循环中使用由 1 中 DFS 得到后序的逆序：找出搜索的下一个顶点时（可在最外层，也可在递归搜索函数返回给顶层搜索函数时调用递归搜索函数），要使用具有最大后序编号未被访问的顶点
    * 任何图都是线性时间、空间：
      * 稠密图：V^2
      * 稀疏图（邻接表）：V+E
  * Tarjan 算法：
    * 步骤：
      1. 以逆拓扑排序的顺序考虑顶点，从而在到达某个顶点的递归函数末尾时知道，将不会遇到同一个强分量中的任何其它顶点，因为由该顶点可达的所有顶点都已被处理完
      2. 树中的回链接为从一个顶点到另一个顶点提供了第二条路径，并将强分量连在一起
    * 进入递归函数时，将顶点压入栈，在访问某个（多个）强分量的最后一个成员时弹出，并赋予分量编号
    * 识别是否在访问强分量的最后一个成员：通过从每个结点的所有子孙的一个上链接来记录最大可达祖先
    * 线性
    * 有向图
  * Gabow's 算法：
    * 与 Tarjan 相似，但使用了第二个栈（包含搜索路径中的顶点），而不是 Tarjan 中的顶点索引的前序编号的数组来确定何时从主栈中弹出每个强分量中的顶点
    * 线性
    * 有向图
* 再论传递闭包：
  * 通过有向图来构建核心 DAG 的不同情况：
    * 核心 DAG 相对于原图来说较小：高效
    * 原图是个DAG：无改进
    * 原图与核心 DAG 规模相类似：不会节省很多
    * 原图有大环或大强分量：最优或渐近最优
  * 抽象传递闭包：
    * 适用于任何有向图
    * 原理：
      * 在同一个强分量中时，顶点相互可达
      * 在核心 DAG 中可达，则在原图中也可达
    * 步骤：
      1. 找出其强分量：Kosaraju、Tarjan、Gabow's
      2. 构建其核心 DAG：对边做一边处理
      3. 计算核心 DAG 的传递闭包：DFS
    * 性能：
      * 计算传递闭包：设 v 为核心 DAG 中顶点数，x 为 DFS 森林中交叉边数，时间：E+v^2+vx，空间：V+v^2
      * 核心 DAG：该核心 DAG 中顶点数少于 `\sqrt[3] v`，时间：E+V，空间：V
* 展望：
  * 以下均用邻接表表示
  * 有向图开销：
  
  | 问题          | 开销（最坏） | 算法                     |
  | :---:         | :---:     | :---:                    |
  | 环检测         | E         | DFS                      |
  | 传递闭包        | V(E+V)   | 从每个顶点开始的 DFS        |
  | 单源点最短路径   | E        | DFS                       |
  | 所有点对最短路径 | V(E+V)    | 从每个顶点开始的 DFS        |
  | 强分量          | E        | Kosaraju、Tarjan、Gabow's |
  | 传递闭包        | E+v(v+x) | 核心 DAG                   |

  * DAG 开销：

  | 问题     | 开销（最坏） | 算法        |
  | :---:   | :---:      | :---:       |
  | 环检测   | E          | DFS或源点队列 |
  | 拓扑排序 | E           | DFS或源点队列 |
  | 传递闭包 | V(V+E)      | DFS         |
  | 传递闭包 | V(V+X)      | DFS或动态规划 |

  * 动态可达性：合并-查找算法（稠密有向图）
  * 问题：
    * 支配者： DFS 线性
    * 传递归约：易解，如果要求结果限制为原图的子图：NP-难
    * 有向欧拉路径：简单
    * 有向邮差问题：易解，归约到最小成本流
    * 有向哈密顿问题：NP-难，如果有向图为 DAG：简单
    * 单连通子图：NP-难
    * 反馈顶点集：NP-难
    * 偶环：不可用

### 第二十章 最小生成树

* 图中每条边上关联权值（成本），成本最小化：
  * 最小生成树：所有点连接起来的最小成本
  * 最短路径：两个给定点之间最小成本的路径
* 最小生成树（MST）：
  * 加权图中权值（边上权值之和）不大于任何其它生成树的权值
  * 边上权值可相等：MST 不是唯一的
* 表示：
  * 表示加权图：
    * 可将权值转换为 0-1 之间的实数
    * 不存在的边：
      * 观察哨权值
      * 平行矩阵：两个矩阵，一个指示边是否存在，另一个保存边权值
    * 邻接矩阵：元素为边权值
    * 邻接表：链表元素增加一个表示边权值的域
  * 表示 MST：
    * 图；边链表；边数组；顶点索引的数组（父链接表示）
    * 以上均可在线性时间互相转换
* MST 算法的基本原理：
  * 基础性质：向树中添加一条边会创建一个环（定义树的性质）
  * 图中的割：将顶点分成两个不相交集的一个划分
  * 交叉边：将两个集合中的顶点连接起来的边
  * 割性质：给定图的任意一个割，每条最小的交叉边属于图中的某个 MST，且每个 MST 包含一条最小交叉边
    * 可用作表征 MST 的优化条件
    * 用来识别出在 MST 中的边：接收这条边
  * 环性质：给定一个原图 G，向原图添加一条边后得到图 G'。将某条边添加到原图 G 的一个 MST 中，并删除所得到的环中最大一条边。这样就得到图 G' 的一个 MST
    * 向一棵生成树不断添加在图中的边，新添加的边需要小于环中的边，从而制造环，并删除环中最大边，直到怎样添加都不能删除。这样就得到一个 MST
    * 用来识别出不在 MST 中的边：拒绝这条边
  * Prim 算法：一次一条边，从任何一个顶点开始，把它作为具有单个顶点的 MST，向它添加 V-1 个顶点，总是取在 MST 中的顶点和不在 MST 中的顶点连接边中的最小边
    * 适合稠密图
  * 反复应用环性质法：向假想 MST 中添加边，如果形成环，则删除环中的最大边
    * 弃用边的难度较大
  * Kruskal 算法：按照边的长度处理边（最短边优先），向 MST 中添加边，不会形成环的边才真正加入 MST 中，在 V-1 条边后停止
  * Boruvka 算法：
    * 步骤：
      1. 向 MST 中添加所有顶点和最近顶点连接起来的边（最小近邻）
      2. 继续向 MST 添加一棵树中的顶点和另一棵树的顶点连接起来的所有边中的最小边（最小近邻）
      3. 直至只剩一棵树
    * 边的权值可相同时：在最小近邻中选择具有最小顶点编号的近邻
  * 抽象操作：
    * 找出连接两棵子树的最小边
    * 确定增加一条边是否会产生一个环
    * 删除环中的最大边
* Prim 算法和优先级优先搜索
  * 描述：维护图的一个割，割由树顶点（在 MST 中的顶点）和非树顶点（不在 MST 中的顶点）组成。从任何在 MST 中的顶点开始，将一条最小交叉边加入到 MST 中（非树顶点变成树顶点），重复 V-1 次，直至所有顶点都在树中
  * 蛮力法：直接可得。选择下一条边的方法：检查从树顶点到非树顶点的所有边中的最小边
  * 增量的变化：只关注由非树顶点到树顶点的最短距离（记录）：
    * V^2，对稠密图来说线性
    * 只检查向树添加顶点后是否需要更新这个最短距离
    * 所需信息：
      * 对于每个树顶点：在 MST 中的父结点；父链接的长度
      * 对于每个非树顶点：最近的树顶点；与树的距离
  * 边缘集：下一次要添加到 MST 中的潜在边集合
  * PFS（广义图搜索）描述：
    * 步骤：
      1. 从边缘集中将一条最小边移到树，并访问该边指向的顶点
      2. 将从该顶点到一个非树顶点的任何边置于边缘集中，如果边缘集中两条边都指向同一个顶点，则用短边取代长边
    * 边缘集为最小优先队列：堆实现时，与 ElgV 成正比
    * 对于任意图和任意优先级函数，在规模至多为 V 的优先队列中，可利用 PFS 找到 MST：线性时间 + V 次插入 + V 次删除最小值 + E 次减少关键字
* Kruskal 算法：
  * 描述：从一个有 V 个单个顶点树的退化森林开始，不断合并两棵树（使用可能的最短边），直至只剩一棵树
  * 经典实现：
    * 步骤：
      1. 按边的权值进行排序，由于权值有限制，可使用基数排序，线性可得，
      2. 使用连通性算法（合并-查找算法）消除导致环的边
    * 开销：ElgE：E 个数排序 + E 次查找 + V-1 次合并
  * 优先队列版本：
    * 线性构造；对数删除最小
    * 开销：E + XlgV，X 为图中不大于 MST 最长边的边数：构造规模为 E 的优先队列 + X 个删除最小 + X 个查找 + V-1 个合并
  * 部分排序版本
* Boruvka 算法：
  * 描述：每步添加数条边到 MST 中，在每一步中，找出连接每棵子树与不同子树的最短边，再将所有这样的边加入 MST 中
  * 连通性算法中的查找函数：为每棵子树关联一个索引，可得知一个给定顶点属于哪棵子树
  * 步骤：
    1. 维护一个顶点索引的数组，对于每个 MST 子树能识别出最近邻
    2. 对图中每条边，边的顶点在同一棵树上时，抛弃；否则检查由该边连接的两棵树之间的最近邻距离，有最近邻则更新距离
    3. 用合并操作将每个顶点与它的最近邻连接起来，然后抛弃目前连通的 MST 子树中连接其它顶点对的所有更长的边
  * O(ElgVlg*E)
* 比较与改进：
  * 稠密图：Prim 算法的邻接矩阵实现经典实现
  * 中等密度图：三种算法皆可，而 Prim 算法的 PFS 实现在取出边的常量因子内
  * 稀疏图：Kruskal 算法，归约为排序（快排）
  * 比较：

  | 算法                               | 最坏情况 | 注释                |
  | :---:                             | :---:   | :---:              |
  | Prim（标准）                       | V^2     | 稠密图最优           |
  | Prim（PFS、堆）                    | ElgV    | 保守上界             |
  | Prim（PFS、d-heap）（Johnson 版本） | Elog_dV | 除极端稀疏图外都是线性 |
  | Kruskal                           | ElgE    | 排序开销占主导       |
  | Kruskal（部分排序）                 | E+XlgV  | 开销依赖最长边       |
  | Boruvka                           | ElgV    | 保守上界            |

  * 改进：
    * 更好的优先队列：如斐波那契堆（Fibonacci 堆）：支持常量减小关键字；对数删除最小
    * 优先队列的实现中使用基数方法
    * 用 d-叉堆实现优先队列：支持 log_dV 减小关键字；dlog_dV 删除最小
      * 改进最坏情况
      * 导致 Prim 算法有 Vdlog_dV + Elog_dV，非稀疏图线性
* 欧几里得 MST：
  * 欧几里得 MST 问题：给定平面 N 个点找出连接所有点的最短线段集合：NlgN
    * 构建 N 顶点、N(N-1)/2 条边的完全图，边权值为两点距离：Prim：N^2
    * Delauney 三角的图由 MST，且是一个边数与 N 成正比的平面图。用 NlogN 计算出 Delauney 三角（太复杂）后运行 Kruskal 或 PFS 找出欧几里得 MST
    * 几何算法
    * 基于近邻算法的 Prim 另一版本

### 第二十一章 最短路径

* 路径权值：那条路径上的边权值之和
* 网（加权有向图）：
  * 网算法同样适用于加权无向图，非加权图也可
  * 自环：表示中保留自环，这样更方便
  * 平行边：可能有平行边，甚至平行边带有不同权值
* 简单有向路径：
  * 正权值边：没必要
  * 负权值边：需要限制为简单路径
* 最短路径：从 s 到 t 的简单有向路径，且不存在有其它更小权值的路径
* 最短路径树（SPT）：定义了从根到其它顶点的最短路径，每条树路径是网中的一条最短路径
* 负环：总权值为负数的有向环
* 源点-汇点最短路径：起始顶点（源点）；完成顶点（汇点）
* 单源点最短路径：找一条最短路径：
  * 最短路径权值
  * 在与长度成正比的时间里追踪路径
* 所有点对最短路径：应用：公路图；航班路线
* 基本原理：
  * 松弛：每步中检查是否可以找到一条比某条已知路径更短的路径
    * 边松弛：检查沿着给定边行进是否会产生到目的顶点的一个新的最短路径
      * 单源点
    * 路径松弛：检查沿着给定边行进是否会产生连接两个其它顶点的一条新的最短路径
      * 所有点对
      * 距离矩阵：d[s][t] 为 s 到 t 的最短路径
      * 路径矩阵：p[s][t] 为 s 到 t 最短路径中 s 的下一个顶点
  * 追踪路径：相反顺序；栈；处理逆图
  * 加号：由边权值计算路径权值
  * 小于号：计算路径权值集中的最小值
* Dijkstra 算法：
  * 定义：从将源点放在 SPT 中开始，然后每次选择一条边构建 SPT，总是选择从源点到不在 SPT 中的一个顶点的最短路径的边
  * 解决非负权值网中的单源点最短路径问题
  * 经典实现适合稠密图，线性，V^2
  * Dijkstra 的 PFS 实现：将连接树顶点与非树顶点的边保存在优先队列，并提供更新优先级的操作
    * 适合稀疏图
    * 用堆来实现优先队列时：ElgV
    * 给定图有 V 个顶点、E 条边、密度 d = E/V：
      * d < 2 时：Dijkstra 时间与 VlgV 成正比
      * 可用 [d]-堆实现优先队列，最坏情况下改进 lg(E/V) 的一个因子：O(Elog_dV)
  * 4 种 PFS 实现：
    * 经典稠密图：Dijkstra、Prim
    * 边缘边集（稀疏图）：教学价值
    * 边缘顶点集（稀疏图）：最优化
    * 所有顶点（稀疏图）：最简单
  * PFS 算法：

  | 算法     | 优先级   | 结果     |
  | :---:   | :---:   | :---:    |
  | DFS     | 逆前序   | 递归树    |
  | BFS     | 前序     | SPT（边） |
  | Prim    | 边权值   | MST      |
  | Djkstra | 路径权值 | SPT       |

  * Dijkstra 算法各种实现的开销：
  
  | 算法                 | 开销（最坏） | 注释                  |
  | :---:               | :---:       | :---:                |
  | 经典                 | V^2        | 稠密图最优             |
  | PFS（完全堆）（所有边） | ElgV       | ADT 简单              |
  | PFS（边缘集堆）        | ElgV       | 保守界限              |
  | PFS（d-叉堆）         | Elog_dV    | 除极端稀疏图外，都是线性 |

* 所有对最短路径：
  * 加权直径：最短路径中最长路径的长度
  * 求所有对最短路径方法：
    * 每个顶点 Dijkstra（非负权值）：
      * 堆：最坏 VElgV    VElog_dV
      * d-叉堆：VE，如果 E < 2V，d = 2；否则 d = E/V
      * 适合稀疏图
    * Floyd（可有负权值，但不能有负环）：
      * V^3
      * 适合稠密图
* 无环网中的最短路径：
  * 无环网中：
    * 单源点：线性，与 E 成正比
    * 所有对：与 VE 成正比
    * 最长路径
  * 无环网（加权 DAG）：边上有权值，且不存在环的有向图
  * 单源点：DFS；源点队列
  * 所有点对：每顶点用单源点；单个 DFS。如果加上动态规划就变成拓扑排序，需用逆拓扑排序顺序考虑顶点
  * 多源点最短路径问题（最长）：
    * 使用虚拟顶点把多源点转化成单源点
    * 按照拓扑排序的顺序处理顶点
    * 线性
* 欧几里得网：
  * 定义：边权值为点的几何距离
  * 额外性质：
    * 满足三角不等式：s->d <= s->x + x->d
    * 顶点位置给出了路径长度的一个下界：不存在有 s->d 的路径小于 s->d 的距离
    * 大大减少必须考虑的路径数目
  * 欧几里得启发式搜索：
    * Dijkstra 的 PFS 实现 + 额外性质
    * 重新加权 + 标准最短路径算法
    * 不保证节省
    * A* 算法的特例
* 归约：
  * A 可归约为 B：使用求解 B 的算法去求解 A，最坏时该算法不超过求解 B 算法的常量倍：
    * 转换为 B 的一个实例
    * 求解这个实例
    * 将 B 的解决方案转换为 A 的解决方案
  * 等价：两个问题可相互归约
  * 体现了归约思想：库编程
  * 作用：分类；得到下界
  * 一个问题比另一个问题更一般
  * 传递闭包可归约为非负权值的所有对最短路径
  * 在边权值无限值的网中，单源点（所有点对）的最长路径问题和最短路径问题是等价的
  * 差分约束：为一组遍历 x_0...x_n 赋予非负值，使 x_n 值最小，且满足对一组变量的差分约束
    * 约束指定了两个变量的差必定大于等于一个给定常量
    * 归约为作业调度
    * 正常数时等价于无环网中单源点最长路径问题
  * 线性规划：为一组变量 x_0...x_n 赋予非负值，使变量的特定线性组合达到最小，且满足对变量的一组约束
    * 约束指定了变量的某个线性组合必定大于等于一个给定常量
  * 不可行的：一个没有解决方案的问题实例
  * 具有截止期限的作业调度：归约为可负权值最短路径（不含负环）
  * 一般的最短路径问题、边权值可为负的网的最短路径问题：NP-难
  * 高效：算法最坏时为输入规模的某个多项式函数
  * 难解性：归约为难解性
  * 上界：有 B 的高效算法，且 A 归约为 B，则有 A 的高效算法。可能有 A 的更好算法，但 B 性能是求 A 最佳性能的一个上界
  * 下界：知道 A 的任何算法都有 x 资源需求，且 A 归约为 B，则 B 至少也由 x 资源需求，因为 B 的更好算法蕴含着存在 A 的一个更好算法，也就是说：A 的性能是 B 最佳性能的一个上界
  * 更一般：运筹学（OR）：数学规划
* 负权值：
  * 正权值：寻找捷径
  * 负权值：寻找绕道，尽可能多的负权边：小权值路径比大权值有更多的边
  * 无负环网中的最短路径问题、负环检测：Floyd 算法，对于所有点对 V^2
  * Bellman-Ford 算法：以任意顺序考虑网中的边，并沿着每条边松弛，执行 V 遍
    * 单源点：VE
    * 所有对：V^2E
    * 负环检测：VE
    * 基本方法：对所有边检查
    * 改进：可改变的边为某些顶点发出的边，而这些顶点在上一遍中有所改变：队列
  * 重新加权：将网转换为只有非负权值的网，且有相同的最短路径结构
    * 操作：
      * 边：将该边源点到目的点权值之差加到该边的权值上
      * 网：对所有边重新加权
    * 线性
    * 顶点的权值：最短路径生成森林：为每个顶点赋权（从此根到它在 SPT 中顶点的路径的权值）
      * 从每个强连通分量的一个源点开始
      * 虚拟顶点，与网中每个顶点之间的边权值为 0
  * Johnson 算法：
    * 适用于有负权边，当无负环的网（所有点对）
    * 步骤：
      1. 用 Bellman-Ford 算法找出原网的一个最短路径森林
      2. 有负环则终止
      3. 由最短路径森林对网进行重新加权
      4. 在重新加权后的网上使用所有点对 Dijkstra 算法
    * 所有点对：VElog_dV，如果 E < 2V，则 d = 2；否则 d = E/V
* 展望：
  * 单源点最短路径算法开销：

  | 权值约束       | 算法            | 开销（最坏） | 注释        |
  | :---:         | :---:          | :---:      | :---:      |
  | 非负           | Dijkstra       | V^2        | 稠密图最优   |
  | 非负           | Dijkstra（PFS） | ElgV       | 保守界      |
  | 无环           | 源点队列         | E          | 最优       |
  | 不含负环        | Bellman-Ford   | VE         | 有改进空间？ |
  | 无（一般性问题） | 开放问题         | ？         | NP-难      |

  * 所有点对最短路径算法开销：

  | 权值约束       | 算法            | 开销（最坏） | 注释        |
  | :---:         | :---:          | :---:      | :---:      |
  | 非负           | Floyd          | V^3        | 对所有网相同 |
  | 非负           | Dijkstra（PFS） | VElgV      | 保守界      |
  | 无环           | DFS            | VE         | 对所有网相同 |
  | 不含负环        | Floyd          | V^3        | 对所有网相同 |
  | 不含负环        | Johnson        | VElgV      | 保守界      |
  | 无（一般性问题） | 开放问题         | ？         | NP-难       |

### 第二十二章 网络流

* 最大流问题、最小成本流问题：
  * 配送：商品配送；通信；交通流量
  * 匹配：工作安排；最小距离点匹配
  * 分割：网络可靠性；分割补给性
* 流网络：
  * st 网：有一个指定源点 s 和一个指定汇点 t 的网
    * 指定：忽略指向 s 的边和指出 t 的边
    * 内部结点：除源点和汇点外的其它顶点
    * 表示：每个方向一条边
      * 邻接矩阵：平行数组
      * 邻接表：一条边两种表示中有指针关联
  * 流网络：有正边权值的 st 网，边上权值为容量
    * 边流（流网络中的一个流）：一个非负边（权值）集合
    * 满足：
      * 边流不大于该边容量
      * 进入每个内部顶点的总流量等于从该顶点流出的总流量
      * s 流出量 = t 流入量
    * 顶点：
      * 流入量：进入一个顶点的总流量（该顶点进入边上的流之和）
      * 流出量：流出一个顶点的总流量（该顶点发出边上的流之和）
    * 网的值 = 源点流出量 = 汇点流入量
  * 最大流：在一个 st 网中找出一个流，使该流的流值最大，且知道达到该流值的各个边值
  * st 流：一个 st 网中的流
  * 合并两个顶点集后仍保持流平衡
  * 循环流：
    * 可以用一条从 s 到 t 的边对任何流网络进行扩展，其中流和容量等于网的值，且对任何扩展过的网络中的结点集，其流入量等于流出量
    * 根据流分解定理，可与环集合（每个环一个流值）互相转换
    * 流分解定理：任何循环流可表示为至多有 E 个有向环的集合上的流
      * 任何 st 网中都有一个最大流，满足非零流值所导出的子图是一个环
      * 任何 st 网中都有一个最大流，可表示为从 s 到 t 的至多 E 个有向路径集合上的流
* 增大路径最大流算法：
  * 增大路径法（Ford-Fulkerson 法）：
    * 描述：从任何一个零流开始，沿着从源点到汇点的任何一条路径上的未满前向边或空的后向边增大此流，继续这个过程直到网络中不存在这样的路径
    * 增加流量：
      * 增加前向边的流：前向边未用流量最小值
      * 减少后向边的流：后向边流的限制
    * 前向边：随着流行进（遍历从源顶点到目的顶点的边）
    * 后向边：沿着流逆行（遍历从目的顶点到源顶点的边）
    * 运行时间：
      * 找出一个最大流所需的增大路径数
      * 找出每个增大路径所需的时间
    * 所需增大路径数目至多为 VM，M 为网络中最大边容量
    * 找出最大流：O(VEM)
    * 稀疏网络：O(V^2M)
    * 图搜索策略：边缘集数据结构，找增大路径的方法
      * 最短增大路径：根据路径上边数
        * 增大路径数目：至多为 VE/2
        * 稀疏网：O(V^3)
        * 队列
      * 最大容量增大路径：沿着使流增大最大量的路径增大
        * 增大路径数目：至多为 2ElgM
        * 稀疏网：O(V^2lgMlgV)
        * 优先队列
      * 栈
      * 随机队列
  * st 割：将顶点 s 放在一个集合，顶点 t 放在另一个集合的割
  * 割集：交叉边的集合（连接这两个集合的边的集合）
  * st 割的容量：该割的所有 st 边的容量之和
  * 穿越 st 割的流：割中 st 边流之和减去割中 ts 边流之和
  * 最小割：给定一个 st 网，找出一个使割的容量达到最小的 st 割
  * 对于任何 st 流，流值等于穿越每个 st 割的流
  * st 流的值都不大于任何 st 割的容量
  * 最大流-最小割定理：网中所有 st 流最大值等于所有 st 割最小值
  * 残量网络：顶点和原网相同。对应于原网中的一条边，有一条或两条边
    * 对于原网中每个边 u-v，设 f 为流值，c 为容量，以下容量为权值：
      * 边空（f=0）：有一条容量为 c 的边 u-v（方向不变）
      * 边满（f=c）：有一条容量为 c 的边 v-u（方向相反）
      * 边不空不满，则有两条边：
        * 正向边容量为 c-f（u-v）
        * 逆向边容量为 f（v-u）
* 预流-推进最大流算法：
  * 描述：沿着顶点的出边逐渐移动流，使流入量多于流出量，直到达到一个可行流（不再存在活动顶点）
  * 可行流：满足平衡条件的流
  * 预流：一个流网络中正边流的集合，满足：
    * 边上流值不大于边上容量
    * 对于每个内部结点流入量不小于流出量
  * 活动顶点：流入量大于流出量的内部结点（约定源点、汇点不是活动顶点）
  * 顶点盈残量：活动顶点流入量减去流出量
  * 改变活动顶点的集合：把活动顶点放入广义队列中，取出一个，沿着一个发出边推进盈残量。如果容量不足，则沿着进入边倒推盈残量；如果推进使这个顶点不平衡，则变成不活动顶点，可能也会激活别的顶点
  * 高度函数：
    * 在一个流网络中给定流的高度函数是一个非负顶点权值集合 h(0)...h(V-1)，且满足对于汇点 t 有 h(t) = 0，对于流的残量网络中每条边 u-v，有 h(u) <= h(v) + 1
    * 合格边：残量网络中满足 h(u) = h(v) + 1 的一条边 u-v
    * 没有合格边：h(0) = h(1) = ... = h(V-1) = 0
    * 设 h(s) = 1，则从源点出发，且有流的任何边都对应着残量网络中的一条合格边
    * 为每个顶点赋以到汇点的最短路径距离：
      * 即以 t 为根的逆网的 BFS 树中到根结点的距离
      * 定义一个高度函数
      * 步骤：
        1. 到 t 的高度必定为 0
        2. 在残量网络中，高度为 1 的顶点被 t 的顶点直接访问
        3. 高度为 2 的顶点被高度为 1 的顶点直接指向
        4. 以此类推
    * 对于任何流和其所关联的高度函数，一个顶点的高度不大于残量网络中从该顶点到汇点的最短路径的长度
    * 含义：当一个活动顶点的高度：
      * 小于源点高度时：结点向汇点推进流
      * 大于源点高度时：结点超出量可被倒推入源点
    * 顶点高度大于 V：在残量网络中不存在从该顶点到汇点的路径
  * 基于边的预流-推进算法：
    * 有任一高度函数，连接到源点的边充满至容量，其它边赋 0 流
    * 步骤：
      1. 选择一个活动顶点，向离开这个顶点的合格边（依靠高度函数识别）（如果有合格边存在）推进流
      2. 如果不存在这样的边，则增加顶点的高度
      3. 直至没有活动顶点存在
    * 保持了高度函数的有效性：O(V^2E)
  * 预流-推进算法性质：
    * 在流网络中执行时，在流网络的残量网络中存在每个活动顶点到源点的一条有向路径，不存在从源点到汇点的有向路径
    * 执行中时，顶点高度总是小于 2V
    * 可计算一个最大流
  * 基于顶点的预流-推进算法：
    * 步骤：
      1. 选择一个活动顶点，向离开顶点的合格边增加流（如果可能则充满）
      2. 继续直到顶点变成不活动的或者不存在合格边
      3. 不存在合格边时，增加顶点的高度
    * 一旦我们选择一个顶点，就尽可能推进它的所有流，如果到了仍有盈余流的顶点但无合格边，就增加顶点的高度
    * FIFO 队列实现：最坏情况下 V^2E
  * 最高顶点预流-推进最大流算法：返回最高活动顶点的优先队列
  * 3 种选择：
    * 基于边与基于顶点的通用算法
    * 广义队列实现
    * 初始高度赋值
* 最大流归约：
  * 可归约为最大流的问题：
    * 一般网中的最大流
    * 顶点容量约束
    * 无环网最大流
    * 无向网最大流
    * 可行流
    * 最大基数二分匹配（二分匹配）：二分图中找最大基数匹配：O(VE)
  * Menger 定理：在有向图中删除某条边使两个顶点不连通的最少边数等于这两个顶点之间边不相交的路径的最大数目
  * 连通度：
    * 边连通度：把图分割成两部分所需删除的最少边数（边集）
    * 顶点连通度：把图分割成两部分所需删除的最少顶点数（顶点集）
  * 无向图边连通度：
    * O(E^2)
    * 最大割集合边数 = 最小流值 = 边连通度
    * 改进：VE
* 最小成本流：
  * 最小成本流模型：允许边上有整数成本，并以自然地方式使用边的成本来定义流成本，然后求出具有最小成本的最大流
  * 边上流成本：边上流和成本的乘积
  * 流成本：一个流的成本为该流中边流成本之和
  * 最小成本最大流：在有边成本的流网络中找出一个最大流使得不存在有更小成本的其它最大流
  * 最小成本可行流：配送网：在有边成本的流网络中对顶点赋予权值，正权值为供应，负权值为需求，且所有顶点权值（等价的）之和为 0.找出有最小成本的一个可行流（平衡）
  * 残量网络扩展：对于每条边 u-v，设 f 为流值，c 为容量，x 为成本
    * f 为正：有一条容量 f、成本 -x 的边
    * f 为负：有一条容量 c-f、成本 x 的边
    * ...
    * 区别：表示后向边的边有负成本
  * 性质：残量网络中不含负成本的环：最小成本最大流
    * 消环算法：
      * 描述：找一个最大流，在残量网中沿着任何负成本的环来增大流，继续这个过程，直到不存在负成本的环
      * 虚拟流初始化（去掉初始最大流的计算）：添加一条从源点到汇点的虚拟边，并赋予最大成本（大于任何源点-汇点路径上的成本）：VC+1；最大流：大于源点流出量
      * 所需的增大环的数目少于 ECM
      * 稀疏图：O(V^3CM)
* 网络单纯形算法：
  * 描述：维护一个树形数据结构，对成本进行重新加权以使负环可被快速识别
  * 对于任意流、每个网络边 u-v 可有 3 种状态：
    * 空：流只能从 u 推入 v：u-v 在残量网中，v-u 不在
    * 满：流只能从 v 推入 u：v-u 在残量网中，u-v 不在
    * 部分（部分边）（不空不满）：流可双向推入：u-v、v-u 都在残量网中
  * 给定一个不含部分边环的最大流，此最大流的一个可行生成树是网络的一棵生成树，包含了所有流的部分边
  * 网络单纯形算法：
    * 第一步：构造一棵生成树：
      * 方法：
        * 计算一个最大流，通过沿着每个环增大从而使其边为空或为满来破坏部分边的环，然后向余下的部分边中添加满边或空边，从而构建一棵生成树
        * 从源点到汇点的一条虚拟边的最大流开始，此边为唯一可能的部分边，可使用任何图搜索方法来构建该流的一棵生成树
    * 基本原理：有一个顶点权值的集合，这些权值可以很快地识别出一些边，这些边被添加到树中时，会在残量网中创建负环
      * 顶点权值：势
      * `\phi (v)`：关联顶点 v 的势
    * 设 c(u, v) 为流的残量网中 u-v 的成本，对于任何势函数 `\phi`，该残量网中的边 u-v 关于 `\phi` 的降低的成本用 c*(u, v) 表示，值为 c*(u, v) = v(u, v) - (`\phi (u)` - `\phi (v)`)：每条边上降低的成本为该边实际成本减去该边顶点势差
    * 使用可行生成树来定义顶点的势，使得关于这些势的降低的边成本直接给出关于负成本环的信息：通过执行算法和设置顶点势的值（使得所有树边可降低的成本为 0）来维护一棵可行生成树
    * 当所有树边可降低的成本为 0 时，称顶点势的集合关于这棵树是有效的：对于任意给定生成树，所有有效的顶点势隐含着每条网络边有相同的降低成本
    * 合格边：
      * 非树边：如果在残量网络中，它与树边创建的环是一个负成本的环
      * 边：
        * 带有可降低成本为正的一条满边
        * 带有负可降低成本的一条空边
      * 有合格边则有负成本的环
      * 无合格边则为最小成本流
      * 最小成本流：树边的降低成本均为 0，满的非树边均为非负的，空的非树边均为非正的
    * 定义：构建一棵可行生成树并维持顶点的势，使其满足所有树顶点的降低成本为 0。向树中添加一条合格边，并沿着用该边与树边形成的环来增大流，从该树中删除满边或空边，继续这一过程直到不存在合格边
    * 可行生成树：顶点的势：降低的成本：合格边：负成本环：减小流成本：树结构的改变：顶点势的改变
    * 3 种涉及树的计算任务：
      * 计算顶点的势：
        * 步骤：
          1. 设根的势为 0， 从任意顶点开始，递归地计算其祖先的势，沿着父链接直到树根
          2. 然后选择另一个顶点，并使用父链接递归计算其祖先的势
          3. 到达一个势已知的祖先顶点时，递归终止且在跳出递归的过程中沿着路径向下行进，通过相应的父结点来计算每个结点的势，继续这一过程，直到计算了所有结点的势
        * 与 V 呈线性
      * 沿着该环增大（并识别其上的空边或满边）：
        * 最小公共祖先（LCA）：两个结点的最小子树的根
        * 添加一条连接两个结点的边而形成了环，这个环由新边和这两个结点到其 LCA 的两条路径上的边组成
        * 步骤：
          1. 通过这两个结点到其 LCA 的任一路径，沿着环增大。示例：为了沿着通过添加新边 u-v 而形成的环增大，可以找到 u 和 v 的 LCA（设为 t），并从 u 到 v，从 v 沿着到 t 的路径及从 u 沿着到 t 的路径推入流，但在相反方向每条边都推入流
          2. 计算推入的流量，用同样的方法遍历环上的边来确定被推入的最大量
        * 与环结点数成正比
      * 在形成的环上插入一条新边和删除一条边（用 u-v 与树边所创建的环中另一条边来代替边 u-v）：
        * 需删除的边在 u 到 LCA 路径上或 v 到 LCA 路径上
        * 将 u-v 之间的链接反向并删除边
        * 如果在增大环中存在多于一条的满边或空边：总是从树中删除与合格边两个顶点 LCA 最近的边
* 最小成本流归约：
  * 最小成本流更具有一般性：任何最小成本最大流都是最大流问题的一个解
  * 最小成本流消环算法给出了最大流问题的一种通用增大路径算法
  * 在最小成本流问题中，可将负成本网转换为非负成本的网
  * 单纯形方法：网络单纯形方法
  * LP 问题：最小成本流问题
  * 归约：
    * 无负环单源点最小路径问题
    * 运输问题等价于最小成本流
    * 分配问题
    * 邮差问题
* 展望：
  * 最大匹配
  * 多商品流
  * 凸包和非线性成本
  * 调度问题